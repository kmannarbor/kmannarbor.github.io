<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Alex Mendiola: Coder - Alex Mendiola</title><link>/</link><description></description><lastBuildDate>Mon, 01 Jul 2019 00:00:00 -0400</lastBuildDate><item><title>Character Frequency Part 2</title><link>/List,%20Sets,%20Dictionaries%20-%20Oh%20my!.html</link><description>&lt;p&gt;Well, after a couple hours of puzziling, I did find a new solution to the common interview question:&lt;/p&gt;
&lt;blockquote&gt;Determine the most frequent character in the following string: "This is a common interview question."&lt;/blockquote&gt;

&lt;p&gt;Before I explain the "correct" solution, here's the second solution that I came up with today:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;sentence&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;This is a common interview question&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;sentence&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sentence&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;sentence&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sentence&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;curr_count&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prev_count&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;largest_count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;prev_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;curr_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;sentence&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;curr_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt;
    &lt;span class="n"&gt;curr_count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;curr_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;prev_name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;prev_count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;curr_count&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;prev_count&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;prev_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;largest_count&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;prev_count&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;largest_count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;prev_count&lt;/span&gt;
                &lt;span class="n"&gt;largest_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;pass&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;curr_count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
            &lt;span class="n"&gt;prev_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;prev_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;curr_name&lt;/span&gt;
        &lt;span class="n"&gt;prev_count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;curr_count&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;largest_name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In this code, I used a for loop with embedded if loops to determine a running count of the frequency of each character. This took into account memory usage (I think) in that it only iterates once through the string - after sorting, lowercasing, and stripping spaces. So, it iterates 4 times. Sheesh!&lt;/p&gt;
&lt;p&gt;After I accomplished the task of determining the most frequent character, I reviewed the solution in the tutorial. In an effort to retain the techniques used, I'll go through it step-by-step:&lt;/p&gt;
&lt;p&gt;First, we need to determine which data structure will be most appropriate for this task. Since we need to store not only the character, but also its frequency in the string, a dictionary will work best. Dictionaries are a collection of key value pairs. In this case our new empty dictionary - &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;char_frequency&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;will store both the character and the frequency count of the character. We set it to empty because we will iterate over the sentence appending it with key value pairs based on the string and each character's frequency thusly: For each character, we verify whether or not it is already recorded in the list. If it does exist in the dictionary, we add 1 to the key value pair of the current character (a task I initially achieved through assigning variables to the current character or previous character's counts). If it does not yet exist in the dictionary, we add a key value pair for the new character.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;sentence&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;char_frequency&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;char&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;char_frequency&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;char&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;char_frequency&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;char&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now that we've iterated through the string once, we now have key value pairs for every character in the string stored in our char_frequency dictionary. The next step is to sort the items in the dictionary in descending order. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;char_frequency&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;However, because dictionaries are collections of key value pairs, we need to specify which of the key values to sort by. In this case, a lambda function will help us do this. Lambda functions are one-time use functions. We use the lambda as a second argument to the sorted function (the first being the iterable char_frequency.items()). The sorted function's second argument must be a key, so we set that key to lambda. Lambdas take a key value pair (in this case kv) and a value (for this lambda we want the second key value in each pair or kv[1].)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;char_frequency&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;kv&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;kv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now we have the list sorted in ascending order by the value of the key pair. But, we need to find the most frequent character, so we reverse the order of the list by calling the final argument of the sorted function by setting reverse equal to true.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;char_frequency&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;kv&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;kv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Okay, we are now able to print the first item in the list. To do this we assign a variable to this line of code and then print the first item in the list.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;char_frequency_sorted&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;char_frequency&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
    &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;kv&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;kv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;char_frequency_sorted&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It is important to note, (as did my mentor) that this code does not take into account capitalization, special characters, spaces, or numbers. Capitalization can be dealt with through an additional iteration using the lower() function and spaces can be eliminated using the replace() function.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;sentence&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sentence&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;sentence&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sentence&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I haven't decided how to exclude special characters or numbers as the interview question does not specify that they should be omitted. I'll update this post when I determine the best way to do so.&lt;/p&gt;
&lt;p&gt;Here is the complete code from the tutorial's solution including my addition to deal with case-sensitivity and spaces:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;sentence&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;This is a common interview question&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;sentence&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sentence&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;sentence&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sentence&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;char_frequency&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;sentence&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;char_frequency&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;char_frequency&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;char&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;char_frequency&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;char&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="n"&gt;char_frequency_sorted&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;char_frequency&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
    &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;kv&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;kv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;char_frequency_sorted&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This second try at coding a solution highlights the adjustment that must be made when learning to code: operational thinking. I have yet to lock-in the necessary questioning pattern that would allow me to quickly and efficiently deal with new coding problems. However, I was able to (given enough time) create 2 working solutions to this particular problem. The second attempt took far less time to find than the first and it also minimized the iterations required to find and return the correct answer. In the future, I will ask the following questions as a starting point:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;What is the best data structure to use in this case?&lt;/li&gt;
    &lt;li&gt;How do I establish the necessary structure?&lt;/li&gt;
    &lt;li&gt;How can I most efficiently iterate over the structure to find the solution?&lt;/li&gt;
    &lt;li&gt;What is the most effective method of returning the solution?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This list will undoubtedly evolve over time and other lists may be needed to solve other types of problems. But, it looks like a good start.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alex Mendiola</dc:creator><pubDate>Mon, 01 Jul 2019 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:None,2019-07-01:/List, Sets, Dictionaries - Oh my!.html</guid><category>Coding</category></item><item><title>Character Frequency Blues</title><link>/Struggling%20with%20Character%20Frequency%20Code.html</link><description>&lt;p&gt;As I review the coding challenges within Code with Mosh's &lt;a href="https://codewithmosh.com/courses" target = "_blank"&gt;Python for Developers&lt;/a&gt; course, the task of determining the most frequently used character in a string confounds me yet again. This time around, I'm able to more efficiently prepare the list of characters for counting, but storing the count of each character eludes me. &lt;/p&gt;
&lt;p&gt;I remember from working with my mentor Joey that my original situation required the string be read each time I counted each character. This got the job done, but was horribly inefficient. Therefore, this time around, I want to record a count only if a character repeats. That way, I only need to read the entire list once. &lt;/p&gt;
&lt;p&gt;This unit of the Python course was by far the most difficult for me to understand and implement. That's why I'm taking my time to rewatch the videos in this section. Another benefit is that I know the challenge as I watch these lessons and approach this second (and sometimes third, fourth, etc.) viewing through the lens of counting characters. I think the issue for me is understanding the typical/practical use cases for each of the techniques with regard to data structures. Furthermore, I need to grasp how the Python interpreter "thinks" about data structures and these methods of interacting with data. &lt;/p&gt;
&lt;p&gt;Joey also pointed out a big failing with the Python language: memory management. Given his role at his company, this is unsurprisingly top of mind for him. How do these procedures perform at scale? In this context, it is clear that I need to structure my code to run as efficiently as possible. Especially if I decide to specialize in Data Science! Building a great algorithm is secondary to delivering a product or analysis in a timely manner.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alex Mendiola</dc:creator><pubDate>Fri, 28 Jun 2019 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:None,2019-06-28:/Struggling with Character Frequency Code.html</guid><category>Coding</category><category>Struggles</category></item><item><title>Personal Coding Bootcamp</title><link>/Personal%20Coding%20Bootcamp.html</link><description>&lt;p&gt;I am a high school English teacher by trade and my summer vacation has just begun. For the past couple of months I formulated plans to gain a working knowledge of software development. I selected Python as my initial language. I worked though the bulk of the Code with Mosh - Python for Developers course. And I added an SSD to my rig and installed Manjaro Linux for my development efforts.&lt;/p&gt;
&lt;p&gt;Over the past two days, I built out my development setup on Manjaro and created this blog. It has been a struggle to develop a workflow for blogging that I feel will be efficient and effective. There are a few improvements to this blog that I have planned, but for now I need to get back to coding.&lt;/p&gt;
&lt;p&gt;I've quickly reviewed the majority of the course that I have already completed. Today, I'll finish that review. My schedule for this Personal Coding Bootcamp is as follows:&lt;/p&gt;
&lt;h3&gt;Monday - Friday&lt;/h3&gt;

&lt;ul&gt;
    &lt;li&gt;8-8:30AM - Exercise&lt;/li&gt;
    &lt;li&gt;8:30-10:30AM - Coding&lt;/li&gt;
    &lt;li&gt;10:30-11AM - Break&lt;/li&gt;
    &lt;li&gt;11AM - 1PM - Coding&lt;/li&gt;
    &lt;li&gt;1-1:30PM - Lunch&lt;/li&gt;
    &lt;li&gt;1:30-6PM - House Projects/Maker Projects/Reading&lt;/li&gt;
    &lt;li&gt;2-4PM - optional 3rd coding block of 2 hours&lt;/li&gt;
    &lt;li&gt;6-7PM - Dinner&lt;/li&gt;
    &lt;li&gt;7-8PM - Gaming&lt;/li&gt;
    &lt;li&gt;8-8:30 - Blog&lt;/li&gt;
    &lt;li&gt;8:30 onward - Entertainment/Relaxation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As you can see, the goal is 4-6 hours of coding each day with a separate 30 mins to update this blog. Let's see how this plan survives battle.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alex Mendiola</dc:creator><pubDate>Wed, 26 Jun 2019 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:None,2019-06-26:/Personal Coding Bootcamp.html</guid><category>Coding</category><category>Bootcamp</category></item><item><title>Welcome</title><link>/Welcome%20to%20my%20blog!.html</link><description>&lt;h1&gt;Welcome!&lt;/h1&gt;

&lt;p&gt;On this blog you will follow my journey from novice Python Developer to competent Developer (and perhaps beyond). I'll chronicle the challenges I come across in my learning and also showcase my projects as I build them. I plan to share my thinking as I move through various tutorials and project builds. My hope is that will help you better understand software development if you are a novice like me. As I progress, I also hope it shows you my dedication and increasing skill. &lt;/p&gt;
&lt;blockquote&gt;"It's good to have an end to journey toward; but it is the journey that matters in the end." -Ernest Hemingway&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alex Mendiola</dc:creator><pubDate>Tue, 25 Jun 2019 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:None,2019-06-25:/Welcome to my blog!.html</guid><category>Welcome</category><category>Intro</category></item><item><title>Relative Paths</title><link>/Relative%20Paths%20in%20VSCode%20on%20Windows.html</link><description>&lt;p&gt;As I continue through the Python for Developers course offered by Mosh Hamedani, I noticed some odd behavior in Visual Studio Code. The relative paths that Mosh was describing returned an error in my code. At first, I solved the issue by creating a raw string. For instance,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;ecommerce&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;didn't work so I copied the full path and used the raw string.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;r&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;C:\Users\rig\coding\python\codeEnv\Mosh\ecommerce&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I realized later that I could use the relative path but I had to include the parent directory displayed in the file tab in Visual Studio Code. In my case...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Mosh\ecommerce&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;worked just fine.&lt;/p&gt;
&lt;p&gt;So, if you're using Windows and Visual Studio Code, be sure to include any parent directories in the file tab when writing relative paths in Visual Studio.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alex Mendiola</dc:creator><pubDate>Mon, 27 May 2019 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:None,2019-05-27:/Relative Paths in VSCode on Windows.html</guid><category>Python</category><category>Coding</category></item><item><title>Successful Deployment of Blog</title><link>/Successful%20Blog%20Deployment.html</link><description>&lt;p&gt;Well, it only took several hours, but the blog is functional. I understand about 30% of the commands I typed into terminal (terminal is weird on Windows! Can't wait for the built in Linux Kernel). I've accepted this phase-state in my learning how to code. Most concepts are partially understood.&lt;/p&gt;
&lt;p&gt;Now that the blog is live and I am fairly confident I'll be able to update it regularly, a note about what you will find here: This will serve, at least initially, as a record of my learning path toward a career in software development/data science. So far, I've begun working through a course on Python for Developers. The last unit which covered lists, dictionaries, lambdas, comphrensions, etc. was particularly difficult. However, the final exercise in which I had to write an algorithm to determine the most frequent character in a string (e.g. "This is a common interview question") was partially solvable for me. I managed to create a program which will correctly solve the problem with any string. My code was not particularly efficient. Luckily, I have a good friend who works at Google. He took a look at my code and provided some interesting insights. First, I was not a total moron in my efforts. I used an extensive series of if statements (one for each letter of the alphabet) to get a count for each letter in the string. He did point out that it required several traversals of the string. This, with a large enough string/input would be memory intensive and provided some ideas to increase the efficiency.&lt;/p&gt;
&lt;p&gt;He mentioned ord() and xrange() both of which I had not yet encountered. This certainly set me at ease. At least I had not overlooked a simple solution which I had already been taught. My ignorance did not impede my ability to solve the problem!&lt;/p&gt;
&lt;p&gt;I'll continue to forge ahead in the course and call on my mentor at Google should I encounter any other obstacles that Stack Overflow and Google cannot provide the necessary insight. And of course I will continue to update my progress here. Once I begin building code, I will post it to github as well. Perhaps with a few more weeks of concentrated study I will be able to give back to the community in some meaningful way... or not... the jury is still out on whether or not I've got the chops for this racket.&lt;/p&gt;
&lt;p&gt;-Alex&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alex Mendiola</dc:creator><pubDate>Thu, 23 May 2019 00:00:00 -0400</pubDate><guid isPermaLink="false">tag:None,2019-05-23:/Successful Blog Deployment.html</guid></item></channel></rss>